{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Deployment Pipeline","text":"<p>A cloud-based deployment pipeline that automatically builds and deploys React.js applications directly from GitHub repositories.</p> <p>This system acts as a simplified version of Vercel, providing developers with continuous deployment, instant hosting, and automatic build management \u2014 all integrated with GitHub.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Deployment Pipeline automates the process of deploying frontend web applications by connecting to a user\u2019s GitHub repository, building the source code, and hosting the final output on the cloud.</p> <p>Once a user signs up, connects a repository, and triggers deployment, the system performs the following steps:</p> <ol> <li>Clone Repository \u2013 The system fetches the codebase from the provided GitHub repository URL.  </li> <li>Build Process \u2013 Code is built inside a secure containerized environment (AWS ECS) using pre-configured Docker images stored in AWS ECR.  </li> <li>Artifact Storage \u2013 The build artifacts (production-ready files) are uploaded to an AWS S3 bucket.  </li> <li>Reverse Proxy Serving \u2013 A custom reverse proxy retrieves files from S3 and streams them to end users via a public deployment URL.  </li> </ol> <p>This provides an end-to-end automated workflow \u2014 from source code to live hosting.</p>"},{"location":"#system-architecture","title":"System Architecture","text":"<p>The project consists of multiple interconnected services:</p> <ul> <li>API Server \u2013 Handles authentication, authorization, deployment requests, and manages project metadata.  </li> <li>Build Servers (AWS ECS Tasks) \u2013 Containerized workers that perform the build and upload artifacts to S3.  </li> <li>Reverse Proxy Server \u2013 Streams built files from S3 to the user\u2019s browser for live preview or production hosting.  </li> <li>Database (PostgreSQL) \u2013 Stores users, projects, and deployment metadata.  </li> <li>Cloud Storage (AWS S3) \u2013 Holds final build outputs.  </li> </ul> <p>User \u2192 API Server \u2192 Build Server (ECS) \u2192 S3 Bucket \u2192 Reverse Proxy \u2192 Live URL</p>"},{"location":"data-modelling/indexing/","title":"Indexing in the Project Database","text":"<p>This section explains the single indexes currently implemented in the project\u2019s PostgreSQL database using Prisma ORM. Indexes improve database performance by enabling faster lookups and filtering during common query operations.</p>"},{"location":"data-modelling/indexing/#user-table","title":"User Table","text":""},{"location":"data-modelling/indexing/#single-index","title":"Single Index","text":"<pre><code>@@index([email])\n</code></pre>"},{"location":"data-modelling/indexing/#explanation","title":"Explanation:","text":"<p>The email field is indexed because it\u2019s frequently queried during authentication. Whenever a user signs up or logs in, the system checks if the email exists \u2014 this index makes that process significantly faster. It complements the @unique constraint on email, ensuring quick lookups and preventing duplicates efficiently.</p>"},{"location":"data-modelling/indexing/#performance-benefit","title":"Performance Benefit:","text":"<p>Faster user retrieval and validation during login or registration.</p>"},{"location":"data-modelling/indexing/#project-table","title":"Project Table","text":""},{"location":"data-modelling/indexing/#single-index_1","title":"Single Index","text":"<pre><code>@@index([gitUrl])\n</code></pre>"},{"location":"data-modelling/indexing/#explaination","title":"Explaination:","text":"<p>The gitUrl field (mapped to git_url in the database) is indexed to speed up queries that search for projects by their linked GitHub repository. It\u2019s commonly used when creating or managing deployments based on a repository URL.</p>"},{"location":"data-modelling/indexing/#performance-benefit_1","title":"Performance Benefit:","text":"<p>Improves performance for operations that fetch projects or deployments using the repository link.</p>"},{"location":"data-modelling/indexing/#deployment-table","title":"Deployment Table","text":""},{"location":"data-modelling/indexing/#single-index_2","title":"Single Index","text":"<pre><code>@@index([status])\n</code></pre>"},{"location":"data-modelling/indexing/#explanation_1","title":"Explanation","text":"<p>The status field is indexed because it\u2019s frequently used for filtering deployments based on their lifecycle state (e.g., QUEUED, RUNNING, COMPLETED). This index helps quickly retrieve all deployments in a particular status for monitoring or background processing tasks.</p>"},{"location":"data-modelling/indexing/#performance-benefit_2","title":"Performance Benefit:","text":"<p>Enhances efficiency of dashboard and worker queries that rely on deployment status filters.</p>"},{"location":"data-modelling/tables-and-er-diagram/","title":"Data Modelling \u2014 Tables and ER Diagram","text":"<p>This section outlines the database schema used in the project, detailing each table, its fields, and their use cases. The schema is implemented using Prisma ORM with a PostgreSQL datasource.</p>"},{"location":"data-modelling/tables-and-er-diagram/#user-table","title":"User Table","text":"Field Type Constraints Description / Use Case <code>id</code> string(UUID) Primary Key Unique identifier for each user. <code>name</code> varchar not null <code>email</code> varchar Unique, Indexed Used for authentication and identification. <code>role_id</code> int User and Admin Role <code>password</code> varchar Securely stored hashed password. <code>created_at</code> timestamp Default: now() Timestamp when the user was created. <code>updated_at</code> timestamp Timestamp for last update. <code>deleted_at</code> timestamp null Timestamp for last delete."},{"location":"data-modelling/tables-and-er-diagram/#project-table","title":"Project Table","text":"Field Type Constraints Description / Use Case <code>id</code> string(UUID) Primary Key Unique project identifier. <code>name</code> varchar Project name displayed in UI. <code>git_url</code> varchar Indexed GitHub repository URL linked to the project. <code>user_id</code> int Foreign Key \u2192 <code>User.id</code> Identifies the owner of the project. <code>created_at</code> timestamp Default: now() Project creation timestamp. <code>github_token</code> varchar Hashed token for GitHub integration, allowing deployments via repositories. <code>updated_at</code> timestamp Timestamp for last <code>deleted_at</code> timestamp null Timestamp for last delete."},{"location":"data-modelling/tables-and-er-diagram/#deployment-table","title":"Deployment Table","text":"Field Type Constraints Description / Use Case <code>id</code> string(UUID) Primary Key Unique deployment identifier. <code>project_id</code> int Foreign Key \u2192 <code>Project.id</code> Identifies the project this deployment belongs to. <code>status</code> varchar Indexed, Default: <code>QUEUED</code> Deployment lifecycle state (<code>QUEUED</code>, <code>RUNNING</code>, <code>COMPLETED</code>, <code>FAILED</code>). <code>created_at</code> timestamp Default: now() Timestamp of deployment creation. <code>updated_at</code> timestamp Timestamp for last <code>deleted_at</code> timestamp null Timestamp for last delete."},{"location":"data-modelling/tables-and-er-diagram/#role-table","title":"Role Table","text":"Field Type Constraints Description / Use Case <code>id</code> string(UUID) Primary Key role identifier. <code>name</code> varchar UK Eg. USER, ADMIN <code>created_at</code> timestamp Default: now() Timestamp of deployment creation. <code>updated_at</code> timestamp Timestamp for last updadeleted_at <code>deleted_at</code> timestamp null Timestamp for last delete."},{"location":"data-modelling/tables-and-er-diagram/#relationships-summary","title":"Relationships Summary","text":"<ul> <li>User \u2192 Project: One-to-Many (a user can own multiple projects).</li> <li>Project \u2192 Deployment: One-to-Many (a project can have multiple deployments).</li> </ul>"},{"location":"data-modelling/tables-and-er-diagram/#entity-relationship-diagram","title":"Entity Relationship Diagram","text":"<pre><code>erDiagram\n    users {\n        string id PK\n        varchar name\n        varchar email UK\n        int role_id FK\n        varchar password\n        timestamp created_at\n        timestamp updated_at\n        timestamp deleted_at\n    }\n\n    roles {\n        string id PK\n        varchar name \n        timestamp created_at\n        timestamp updated_at\n        timestamp deleted_at\n    }\n\n    projects {\n        string id PK\n        varchar name\n        varchar git_url\n        int user_id FK\n        timestamp created_at\n        timestamp updated_at\n        timestamp deleted_at\n    }\n\n    deployments {\n        string id PK\n        int project_id FK\n        varchar status\n        timestamp created_at\n        timestamp updated_at\n        timestamp deleted_at\n    }\n\n    roles ||--o{ users : \"assigns\"\n    users ||--o{ projects : \"owns\"\n    projects ||--o{ deployments : \"has\"\n</code></pre>"},{"location":"functional/data-flow-diagram/","title":"Data Flow Diagram","text":"<p>This diagram shows the flow of data in the deployment platform project, including backend services, user/admin interactions, and deployment processes.</p> <p></p>"},{"location":"functional/functional-usecases/","title":"Functional Use Cases","text":"<p>This section defines the main functional behaviors of the Deployment Pipeline. Each use case explains how different system components interact internally to deliver a key feature.</p>"},{"location":"functional/functional-usecases/#1-user-authentication-and-authorization","title":"1. User Authentication and Authorization","text":"<p>Goal: Provide secure sign-up and login for users.</p> <p>Flow: 1. User sends a sign-up or login request to the API server. 2. Server validates input and checks the database for existing users. 3. Passwords are hashed and stored securely. 4. On successful login, a JWT token is generated and returned. 5. Subsequent requests include this token for authorization.</p> <p>System Behavior: - Validations ensure unique emails and secure passwords. - Tokens are time-bound and refreshable. - Unauthorized access attempts return appropriate errors.</p>"},{"location":"functional/functional-usecases/#2-project-management","title":"2. Project Management","text":"<p>Goal: Allow authenticated users to create and manage deployable projects linked to GitHub repositories.</p> <p>Flow: 1. User provides project name and GitHub repo URL. 2. API validates the URL format and ensures it\u2019s accessible. 3. A project entry is created in the database and linked to the user. 4. Frontend displays the project dashboard with deployment options.</p> <p>System Behavior: - Ensures no duplicate project names for a single user. - Maintains relationship between users, projects, and deployments. - Prepares metadata for future deployment builds.</p>"},{"location":"functional/functional-usecases/#3-build-and-deployment-execution","title":"3. Build and Deployment Execution","text":"<p>Goal: Automate the build and deployment process when a user triggers a deployment.</p> <p>Flow: 1. User triggers Deploy from the dashboard. 2. API creates a deployment record and pushes a build task to ECS. 3. The ECS container clones the GitHub repository from the provided URL. 4. The build process (<code>npm install</code>, <code>npm run build</code>, etc.) runs inside the container. 5. Build artifacts are uploaded to an S3 bucket. 6. Deployment status (<code>queued</code>, <code>running</code>, <code>success</code>, <code>failed</code>) is updated in the database.</p> <p>System Behavior: - Uses AWS ECS for isolated build execution. - Logs are collected and streamed back to the backend. - On successful build, an accessible URL is generated via CloudFront or reverse proxy.</p>"},{"location":"functional/functional-usecases/#4-reverse-proxy-and-file-streaming","title":"4. Reverse Proxy and File Streaming","text":"<p>Goal: Deliver the deployed React app to end users efficiently.</p> <p>Flow: 1. User accesses the generated deployment URL. 2. Reverse proxy receives the request and retrieves static assets from the S3 bucket. 3. The files are streamed back to the client\u2019s browser.</p>"},{"location":"functional/functional-usecases/#5-use-case-diagram","title":"5. Use Case Diagram","text":"<p>This diagram visually maps the actors and their interaction with the main system features discussed in the functional requirements.</p> <p></p>"},{"location":"functional/overview/","title":"System Overview","text":"<p>The Deployment Pipeline automates the process of building, deploying, and hosting frontend applications directly from GitHub repositories. It enables users to go from source code to a live, shareable URL without manual setup or server configuration.</p>"},{"location":"functional/overview/#workflow-summary","title":"Workflow Summary","text":"<p>When a user provides a GitHub repository URL and triggers deployment, the system executes a series of automated functions that ensure seamless application delivery.</p>"},{"location":"functional/overview/#end-to-end-deployment-flow","title":"End-to-End Deployment Flow","text":"<ol> <li>Repository Cloning </li> <li>The API server authenticates the GitHub URL provided by the user.  </li> <li>The build server securely clones the source code repository into an isolated environment.  </li> <li> <p>Only the latest branch or commit is fetched to optimize performance and reduce build time.</p> </li> <li> <p>Automated Build Process </p> </li> <li>A build server, running as an ECS task, builds the project using pre-defined Docker images stored in AWS ECR.  </li> <li>The environment includes dependencies such as Node.js to compile React applications.  </li> <li> <p>Once the build completes, the system generates production-ready files (HTML, CSS, JS).</p> </li> <li> <p>Artifact Upload to AWS S3 </p> </li> <li>The built static files are uploaded to a designated S3 bucket.  </li> <li>The system assigns each deployment a unique directory or version ID for organized storage and rollback capability.  </li> <li> <p>Appropriate access policies are applied to ensure security and isolation per project.</p> </li> <li> <p>Serving via Reverse Proxy </p> </li> <li>A custom reverse proxy fetches files from S3 in real time and streams them to clients.  </li> <li>It ensures low latency, caching, and HTTPS support.  </li> <li>This allows users to instantly access the deployed application via a generated live URL.</li> </ol>"},{"location":"functional/overview/#core-functional-modules","title":"Core Functional Modules","text":"<p>The system is divided into several modules that work together to achieve complete automation:</p>"},{"location":"functional/overview/#1-user-authentication-and-autherization","title":"1. User Authentication and Autherization","text":"<p>Handles secure access to the system. - Users can sign up, log in, and manage their profiles. - Passwords are encrypted before storage. - JWT (JSON Web Tokens) or session-based authentication ensures secure API communication.</p>"},{"location":"functional/overview/#2-project-management","title":"2. Project Management","text":"<p>Links user accounts to their GitHub repositories. - Users can create, view, and manage projects. - Each project record stores metadata such as repository URL, project name, and user ID. - A single user can have multiple projects.</p>"},{"location":"functional/overview/#3-automated-build-deployment","title":"3. Automated Build &amp; Deployment","text":"<p>Responsible for compiling and preparing production builds. - The API server triggers a build job using AWS ECS tasks. - Each build is isolated and stateless, ensuring consistency and reproducibility. - Logs, build status, and progress are tracked and linked to a specific deployment record.</p>"},{"location":"functional/overview/#4-file-hosting-and-delivery","title":"4. File Hosting and Delivery","text":"<p>Ensures fast and reliable access to deployed applications. - Build artifacts are uploaded to AWS S3 with public-read or signed URL access. - A reverse proxy layer retrieves and streams these files to users in real time. - This design supports horizontal scaling for high-traffic applications.</p>"},{"location":"functional/overview/#5-database-management","title":"5. Database Management","text":"<p>Stores essential project data and deployment history. - PostgreSQL is used for relational data storage. - Contains three main tables:   - Users \u2192 Authentication and user profiles.   - Projects \u2192 Repository and configuration details.   - Deployments \u2192 Build metadata, status, and generated URLs. - The database enables tracking deployment versions, history, and ownership.</p>"},{"location":"functional/overview/#functional-flow-summary","title":"Functional Flow Summary","text":"<p>User \u2192 API Server \u2192 Build Server (ECS) \u2192 AWS S3 \u2192 Reverse Proxy \u2192 Live App</p>"},{"location":"technical-document/architecture/","title":"AWS Infrastructure Architecture","text":""},{"location":"technical-document/architecture/#overview","title":"Overview","text":"<p>This document describes the complete AWS infrastructure setup for the project, including all cloud services and their interactions.</p>"},{"location":"technical-document/architecture/#infrastructure-diagram","title":"Infrastructure Diagram","text":""},{"location":"technical-document/architecture/#ec2","title":"EC2","text":"<p>Frontend is deployed on EC2</p>"},{"location":"technical-document/architecture/#aws-services","title":"AWS Services","text":""},{"location":"technical-document/architecture/#core-services-used","title":"Core Services Used","text":"<ol> <li>Amazon VPC (Virtual Private Cloud)</li> <li>Amazon EC2 (Elastic Compute Cloud)</li> <li>Amazon ECR (Elastic Container Registry)</li> <li>Amazon ECS (Elastic Container Service)</li> <li>Amazon S3 (Simple Storage Service)</li> </ol>"},{"location":"technical-document/architecture/#network-architecture","title":"Network Architecture","text":""},{"location":"technical-document/architecture/#virtual-public-cloud-vpc","title":"Virtual Public Cloud (VPC)","text":"<p>The entire infrastructure is contained within an AWS VPC, providing network isolation and security.</p>"},{"location":"technical-document/architecture/#public-subnet","title":"Public Subnet","text":"<p>Contains publicly accessible resources: - Amazon EC2 (Backend): Application server - Amazon ECS: Container orchestration service</p>"},{"location":"technical-document/architecture/#public-subnet-components","title":"Public Subnet Components","text":"<p>Amazon EC2 (Backend) - Hosts the backend application - Publicly accessible via internet - Connects to Amazon RDS for data persistence</p> <p>Amazon ECS - Container orchestration platform - Pulls images from Amazon ECR - Connects to S3 bucket for storage operations</p>"},{"location":"technical-document/architecture/#service-components","title":"Service Components","text":""},{"location":"technical-document/architecture/#compute-layer","title":"Compute Layer","text":""},{"location":"technical-document/architecture/#amazon-ec2-backend","title":"Amazon EC2 (Backend)","text":"<ul> <li>Purpose: Hosts backend application server</li> <li>Network: Public subnet</li> <li>Connections: </li> <li>Upstream: User requests</li> </ul>"},{"location":"technical-document/architecture/#amazon-ecs-elastic-container-service","title":"Amazon ECS (Elastic Container Service)","text":"<ul> <li>Purpose: Container orchestration and management</li> <li>Network: Public subnet</li> <li>Connections:</li> <li>Upstream: Amazon ECR (pulls container images)</li> <li>Downstream: S3 bucket (stores outputs)</li> </ul>"},{"location":"technical-document/architecture/#container-registry","title":"Container Registry","text":""},{"location":"technical-document/architecture/#amazon-ecr-elastic-container-registry","title":"Amazon ECR (Elastic Container Registry)","text":"<ul> <li>Purpose: Stores Docker container images</li> <li>Access: ECS pulls images for deployment</li> <li>Integration: Part of the CI/CD pipeline</li> </ul>"},{"location":"technical-document/architecture/#database-layer","title":"Database Layer","text":"<p>Aiven Cloud is used</p>"},{"location":"technical-document/architecture/#storage-layer","title":"Storage Layer","text":""},{"location":"technical-document/architecture/#s3-bucket","title":"S3 Bucket","text":"<ul> <li>Purpose: Object storage for application outputs</li> <li>Access: Connected to Amazon ECS</li> <li>Use Cases:</li> <li>Build artifacts storage</li> <li>Static asset hosting</li> <li>Application outputs</li> <li>Project files</li> </ul>"},{"location":"technical-document/authentication-and-autherization/","title":"Authentication and Authorization","text":""},{"location":"technical-document/authentication-and-autherization/#overview","title":"Overview","text":"<p>This document describes the authentication and authorization mechanisms implemented in the project. The system uses JWT-based authentication with role-based access control (RBAC) to secure endpoints and features.</p>"},{"location":"technical-document/authentication-and-autherization/#authentication","title":"Authentication","text":""},{"location":"technical-document/authentication-and-autherization/#authentication-methods","title":"Authentication Methods","text":"<p>The system supports two authentication methods:</p> <ol> <li>Email/Password Authentication</li> <li>GitHub Token Authentication</li> </ol>"},{"location":"technical-document/authentication-and-autherization/#signup-process","title":"Signup Process","text":""},{"location":"technical-document/authentication-and-autherization/#user-registration","title":"User Registration","text":"<p>Users can register with the following information:</p> <ul> <li>Name: Full name of the user</li> <li>Email: Valid email address (unique)</li> <li>Password: Secure password (hashed before storage)</li> <li>Role: User role (<code>ADMIN</code> or <code>USER</code>)</li> </ul>"},{"location":"technical-document/authentication-and-autherization/#signup-flow","title":"Signup Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant Database\n    participant JWT\n\n    Client-&gt;&gt;API: POST /auth/signup\n    Note over Client,API: {name, email, password, role}\n    API-&gt;&gt;API: Validate input data\n    API-&gt;&gt;API: Hash password\n    API-&gt;&gt;Database: Create user record\n    Database--&gt;&gt;API: User created\n    API-&gt;&gt;JWT: Generate JWT token\n    JWT--&gt;&gt;API: Return token\n    API--&gt;&gt;Client: 201 Created {token, user}\n</code></pre>"},{"location":"technical-document/authentication-and-autherization/#login-process","title":"Login Process","text":""},{"location":"technical-document/authentication-and-autherization/#user-login","title":"User Login","text":"<p>Users authenticate using:</p> <ul> <li>Email: Registered email address</li> <li>Password: User password</li> </ul>"},{"location":"technical-document/authentication-and-autherization/#login-flow","title":"Login Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant Database\n    participant JWT\n\n    Client-&gt;&gt;API: POST /auth/login\n    Note over Client,API: {email, password}\n    API-&gt;&gt;Database: Find user by email\n    Database--&gt;&gt;API: User data\n    API-&gt;&gt;API: Verify password hash\n    alt Password Valid\n        API-&gt;&gt;JWT: Generate JWT token\n        JWT--&gt;&gt;API: Return token\n        API--&gt;&gt;Client: 200 OK {token, user}\n    else Password Invalid\n        API--&gt;&gt;Client: 401 Unauthorized\n    end\n</code></pre>"},{"location":"technical-document/authentication-and-autherization/#complete-authentication-flow","title":"Complete Authentication Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant Auth Middleware\n    participant Database\n\n    Client-&gt;&gt;API: Request with JWT\n    API-&gt;&gt;Auth Middleware: Validate token\n    Auth Middleware-&gt;&gt;Auth Middleware: Verify signature\n    Auth Middleware-&gt;&gt;Auth Middleware: Check expiration\n\n    alt Token Valid\n        Auth Middleware-&gt;&gt;Database: Get user data\n        Database--&gt;&gt;Auth Middleware: User data\n        Auth Middleware-&gt;&gt;API: Attach user to request\n        API-&gt;&gt;API: Process request\n        API--&gt;&gt;Client: Response\n    else Token Invalid/Expired\n        Auth Middleware--&gt;&gt;Client: 401 Unauthorized\n    end\n</code></pre>"},{"location":"technical-document/authentication-and-autherization/#github-token-authentication","title":"GitHub Token Authentication","text":"<p>Users can authenticate using GitHub personal access tokens for project creation and management.</p>"},{"location":"technical-document/authentication-and-autherization/#github-auth-flow","title":"GitHub Auth Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant GitHub\n\n    Client-&gt;&gt;API: Request with GitHub Token\n    Note over Client,API: Header: Authorization: Bearer {gitToken}\n    API-&gt;&gt;GitHub: Validate token\n    GitHub--&gt;&gt;API: Token valid/invalid\n    alt Token Valid\n        API-&gt;&gt;API: Process request\n        API--&gt;&gt;Client: 200 OK with data\n    else Token Invalid\n        API--&gt;&gt;Client: 401 Unauthorized\n    end\n</code></pre>"},{"location":"technical-document/authentication-and-autherization/#authorization","title":"Authorization","text":""},{"location":"technical-document/authentication-and-autherization/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<p>The system implements role-based access control with two primary roles:</p> <ol> <li>ADMIN: Full access to all features</li> <li>USER: Limited access based on permissions</li> </ol>"},{"location":"technical-document/authentication-and-autherization/#admin-flow","title":"Admin Flow","text":""},{"location":"technical-document/authentication-and-autherization/#admin-capabilities","title":"Admin Capabilities","text":"<p>After signup with role <code>ADMIN</code>, administrators can:</p> <ol> <li> <p>Create Projects          Project name             Git URL             Git token</p> </li> <li> <p>Deploy Projects          Single button deployment              Full deployment control</p> </li> <li> <p>Grant Permissions          View list of all users              Grant/revoke access to specific users              Manage user permissions per project</p> </li> </ol>"},{"location":"technical-document/authentication-and-autherization/#admin-authorization-flow","title":"Admin Authorization Flow","text":"<pre><code>sequenceDiagram\n    participant Admin\n    participant API\n    participant Database\n\n    Admin-&gt;&gt;API: Create Project\n    Note over Admin,API: {name, gitURL, gitToken}\n    API-&gt;&gt;API: Verify JWT (role=ADMIN)\n    API-&gt;&gt;Database: Create project\n    Database--&gt;&gt;API: Project created\n\n    Admin-&gt;&gt;API: Grant permission to user\n    Note over Admin,API: {userId, projectId}\n    API-&gt;&gt;API: Verify JWT (role=ADMIN)\n    API-&gt;&gt;Database: Create permission record\n    Database--&gt;&gt;API: Permission granted\n    API--&gt;&gt;Admin: Success\n</code></pre>"},{"location":"technical-document/authentication-and-autherization/#user-flow","title":"User Flow","text":""},{"location":"technical-document/authentication-and-autherization/#user-capabilities","title":"User Capabilities","text":"<p>After signup with role <code>USER</code>, regular users have:</p> <ol> <li> <p>Limited Access     Can only access projects they're granted permission to     Cannot create new projects     Cannot grant permissions to others</p> </li> <li> <p>Permission-Based Actions With Permission: Can deploy assigned projects  Without Permission: Receive unauthorized access error</p> </li> </ol>"},{"location":"technical-document/authentication-and-autherization/#user-authorization-flow","title":"User Authorization Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant API\n    participant Database\n\n    User-&gt;&gt;API: Access/Deploy Project\n    Note over User,API: projectId in request\n    API-&gt;&gt;API: Verify JWT (role=USER)\n    API-&gt;&gt;Database: Check permission\n    Note over API,Database: WHERE userId AND projectId\n\n    alt Has Permission\n        Database--&gt;&gt;API: Permission found\n        API-&gt;&gt;API: Process deployment\n        API--&gt;&gt;User: 200 OK - Deploy initiated\n    else No Permission\n        Database--&gt;&gt;API: Permission not found\n        API--&gt;&gt;User: 403 Forbidden - Unauthorized Access\n    end\n</code></pre>"},{"location":"technical-document/data-flow-diagram/","title":"Data-Flow-Diagram","text":"<p>The following diagram illustrates the detailed data flow of the project, including user interactions, backend services, deployment, and storage.</p> <p></p>"},{"location":"technical-document/technical-stack/","title":"Technical Stack","text":"<p>This project is built using a modern and stable technology stack to ensure scalability, maintainability, and ease of deployment. Below are the choices made for each layer of the application:</p>"},{"location":"technical-document/technical-stack/#frontend","title":"Frontend","text":"<ul> <li>React </li> <li>Version: 18.x (Stable)  </li> <li>Reason: React provides a component-based architecture and reactive UI, making it ideal for building dynamic and responsive web applications. Vite is used as the build tool for faster development and optimized production builds.</li> </ul>"},{"location":"technical-document/technical-stack/#backend","title":"Backend","text":"<ul> <li>Node.js + Express </li> <li>Version: Node.js 20.x (LTS), Express 4.x (Stable)  </li> <li>Reason: Node.js allows building scalable server-side applications using JavaScript. Express is lightweight and provides a flexible framework for handling APIs and routing.</li> </ul>"},{"location":"technical-document/technical-stack/#database","title":"Database","text":"<ul> <li>Prisma ORM with PostgreSQL </li> <li>Version: Prisma 5.x, PostgreSQL 16.x  </li> <li>Reason: Prisma provides a type-safe ORM for database operations, reducing errors and improving development speed. PostgreSQL is a reliable relational database with strong consistency and support for complex queries.</li> </ul>"},{"location":"technical-document/technical-stack/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<ul> <li>JWT (JSON Web Token) </li> <li>Version: 9.x (Stable)  </li> <li>Reason: JWT allows stateless authentication, making it easy to manage sessions securely for users and support role-based access (Admin/User).</li> </ul>"},{"location":"technical-document/technical-stack/#cloud-services","title":"Cloud Services","text":"<ul> <li>AWS ECS (Elastic Container Service) </li> <li>Reason: Hosts Docker containers and scales applications automatically.  </li> <li>AWS ECR (Elastic Container Registry) </li> <li>Reason: Stores Docker images securely and integrates with ECS for deployments.  </li> <li>AWS S3 (Simple Storage Service) </li> <li>Reason: Stores static files (HTML, CSS, JS) and serves them efficiently via a reverse proxy.  </li> </ul>"},{"location":"technical-document/technical-stack/#other-tools-libraries","title":"Other Tools &amp; Libraries","text":"<ul> <li>Bcrypt for password hashing (ensures secure storage of user credentials)  </li> <li>Zod for input validation (ensures backend receives validated and structured data)  </li> <li>Cors middleware for handling cross-origin requests  </li> <li>dotenv for managing environment variables securely  </li> </ul> <p>This tech stack is chosen for its stability, support, and ease of integration with AWS for containerized deployments.</p>"},{"location":"technical-document/test-plan/","title":"Unit Test Plan \u2013 Deployment Pipeline Platform","text":""},{"location":"technical-document/test-plan/#1-introduction","title":"1. Introduction","text":"<p>This document explains the unit testing plan for the Deployment Pipeline Platform project. It covers both the frontend (React) and backend (Node.js/Express + Prisma). The main goal is to ensure each part of the system works correctly before deployment and that critical functionalities are thoroughly tested.</p>"},{"location":"technical-document/test-plan/#2-objective","title":"2. Objective","text":"<p>The main objectives of unit testing are to:</p> <ul> <li>Verify that every function, component, and service performs as expected.</li> <li>Detect and fix bugs early in development.</li> <li>Maintain clean, stable, and maintainable code.</li> <li>Ensure new updates do not break existing features.</li> <li>Maintain test coverage targets for critical modules.</li> </ul>"},{"location":"technical-document/test-plan/#3-scope","title":"3. Scope","text":""},{"location":"technical-document/test-plan/#included","title":"Included","text":"<ul> <li>Frontend: React components, hooks, API services, and utility functions.</li> <li>Backend: Controllers, services, utils, Prisma logic, and database interactions.</li> </ul>"},{"location":"technical-document/test-plan/#excluded","title":"Excluded","text":"<ul> <li>End-to-end testing (handled in separate e2e plan)</li> <li>Integration with third-party services (except for mocks)</li> </ul>"},{"location":"technical-document/test-plan/#4-test-architecture-folder-structure","title":"4. Test Architecture / Folder Structure","text":"<p>Organize tests in a clear folder structure:</p> <pre><code>frontend/\n \u251c\u2500 src/\n \u2502   \u251c\u2500 components/\n \u2502   \u2502   \u2514\u2500 __tests__/\n \u2502   \u251c\u2500 hooks/\n \u2502   \u2502   \u2514\u2500 __tests__/\n \u2502   \u2514\u2500 services/\n \u2502       \u2514\u2500 __tests__/\n\nbackend/\n \u251c\u2500 src/\n \u2502   \u251c\u2500 controllers/\n \u2502   \u2502   \u2514\u2500 __tests__/\n \u2502   \u251c\u2500 services/\n \u2502   \u2502   \u2514\u2500 __tests__/\n \u2502   \u251c\u2500 utils/\n \u2502   \u2502   \u2514\u2500 __tests__/\n \u2502   \u2514\u2500 prisma/\n \u2502       \u2514\u2500 __tests__/\n</code></pre>"},{"location":"technical-document/test-plan/#5-test-approach","title":"5. Test Approach","text":"<p>We will use Jest as the main testing framework, with additional tools for frontend and backend.</p>"},{"location":"technical-document/test-plan/#frontend","title":"Frontend","text":"<ul> <li>Tools: Jest + React Testing Library</li> <li> <p>Focus Areas:</p> </li> <li> <p>Component rendering and behavior</p> </li> <li>Form validation and API calls (mocked)</li> <li>Hooks and utility functions</li> <li>Negative test cases (e.g., invalid input, API errors)</li> </ul>"},{"location":"technical-document/test-plan/#backend","title":"Backend","text":"<ul> <li>Tools: Jest + Supertest + Prisma Test Client</li> <li> <p>Focus Areas:</p> </li> <li> <p>Controller routes and API responses</p> </li> <li>Business logic in services</li> <li>Utility functions (validation, formatting, etc.)</li> <li>Mocked database and external services</li> <li>Negative test cases (e.g., invalid input, duplicate records, failed DB calls)</li> </ul>"},{"location":"technical-document/test-plan/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li>All tests are run automatically via GitHub Actions in the CI/CD pipeline.</li> <li>Pipeline will fail if critical tests fail or coverage is below the target.</li> <li>Coverage reports will be generated for every pull request.</li> </ul>"},{"location":"technical-document/test-plan/#6-coverage-targets","title":"6. Coverage Targets","text":"<ul> <li>Maintain \u2265 70\u201380% coverage for all critical frontend and backend modules.</li> <li>Coverage thresholds will be enforced via CI/CD.</li> <li>Reports generated using:</li> </ul> <pre><code>npm run test:coverage\n</code></pre>"},{"location":"technical-document/test-plan/#7-test-cases-examples","title":"7. Test Cases (Examples)","text":""},{"location":"technical-document/test-plan/#frontend_1","title":"Frontend","text":"Module Test Case Expected Result Login Component Valid credentials Redirects to dashboard Login Component Invalid credentials Shows error message Signup Component Invalid email Shows validation error Signup Component Duplicate email Shows conflict error useAuth Hook Logout Clears token and redirects API Service Fetch project list Returns mocked data successfully Project Form Submit with missing fields Shows validation error (negative case)"},{"location":"technical-document/test-plan/#backend_1","title":"Backend","text":"Module Test Case Expected Result AuthController Register user Returns 201 with user data AuthController Register duplicate user Returns 409 Conflict AuthService Generate JWT token Returns valid token PipelineService Create pipeline Returns success response PipelineService Create pipeline with invalid data Returns 400 Bad Request (negative case) Utils Validate email function Returns true/false correctly Database Prisma create user Successfully persists user Database Prisma create duplicate user Throws error (negative case)"},{"location":"technical-document/test-plan/#8-test-schedule","title":"8. Test Schedule","text":"Activity Responsible Timeframe Write unit test cases Myself During development Execute tests locally Myself Before each commit or push Fix and retest Myself Immediately after test failures Final test review Mentors Before deployment or submission CI/CD Integration Verification Myself / Mentors During development &amp; PR"},{"location":"technical-document/test-plan/#9-responsibility","title":"9. Responsibility","text":"<p>I am responsible for writing, running, and maintaining all unit tests for both frontend and backend. Mentors will review final results, verify coverage, and approve before deployment.</p>"},{"location":"technical-document/test-plan/#10-risks","title":"10. Risks","text":"Risk Impact Mitigation Limited time for writing tests Medium Write tests alongside coding Low coverage Medium Track coverage reports regularly; enforce minimum thresholds Mocking external APIs incorrectly High Use proper mocking libraries; review mocks regularly Skipped updates to tests after code changes Medium Update tests concurrently with feature changes"},{"location":"technical-document/test-plan/#11-tools","title":"11. Tools","text":"Tool Purpose Jest Testing framework for frontend &amp; backend React Testing Library Testing React components Supertest Testing backend routes Prisma Test Client Mocking Prisma DB calls ESLint / Prettier Code formatting and linting GitHub Actions CI/CD to run tests and enforce coverage"},{"location":"technical-document/test-plan/#12-commands","title":"12. Commands","text":"<pre><code># Run all tests\nnpm run test\n\n# Run tests with coverage report\nnpm run test:coverage\n</code></pre>"},{"location":"use-cases/business-overview/","title":"Business Overview","text":""},{"location":"use-cases/business-overview/#objective","title":"Objective","text":"<p>To provide a seamless automated deployment solution for frontend developers who want to host React applications quickly, without worrying about the underlying infrastructure and hosting the frontend application.</p>"},{"location":"use-cases/business-overview/#stakeholders","title":"Stakeholders","text":"<ul> <li>End Users (Developers): Use the platform to deploy and host React apps.</li> <li>DevOps Team: Maintain build servers, monitor deployments, ensuring scalability and uptime.</li> <li>Admin: Maintain build servers, monitor deployments.</li> <li>Business Owner: Ensures scalability, manages billing and uptime.</li> </ul>"},{"location":"use-cases/business-overview/#business-problem","title":"Business Problem","text":"<p>Manual deployment and hosting are time-consuming and error-prone. This project provides one-click continuous deployment from GitHub to a live URL.</p>"},{"location":"use-cases/business-overview/#business-value","title":"Business Value","text":"<ul> <li>Reduces deployment time from hours to minutes.</li> <li>Simplifies hosting workflow for developers.</li> <li>Encourages CI/CD adoption. ``</li> </ul>"}]}