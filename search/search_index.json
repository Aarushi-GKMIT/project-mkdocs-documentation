{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Deployment Pipeline (Vercel Clone)","text":"<p>A cloud-based deployment pipeline that automatically builds and deploys React.js applications directly from GitHub repositories.</p> <p>This system acts as a simplified version of Vercel, providing developers with continuous deployment, instant hosting, and automatic build management \u2014 all integrated with GitHub.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Deployment Pipeline automates the process of deploying frontend web applications by connecting to a user\u2019s GitHub repository, building the source code, and hosting the final output on the cloud.</p> <p>Once a user signs up, connects a repository, and triggers deployment, the system performs the following steps:</p> <ol> <li>Clone Repository \u2013 The system fetches the codebase from the provided GitHub repository URL.  </li> <li>Build Process \u2013 Code is built inside a secure containerized environment (AWS ECS) using pre-configured Docker images stored in AWS ECR.  </li> <li>Artifact Storage \u2013 The build artifacts (production-ready files) are uploaded to an AWS S3 bucket.  </li> <li>Reverse Proxy Serving \u2013 A custom reverse proxy retrieves files from S3 and streams them to end users via a public deployment URL.  </li> </ol> <p>This provides an end-to-end automated workflow \u2014 from source code to live hosting.</p>"},{"location":"#system-architecture","title":"System Architecture","text":"<p>The project consists of multiple interconnected services:</p> <ul> <li>API Server \u2013 Handles authentication, deployment requests, and manages project metadata.  </li> <li>Build Servers (AWS ECS Tasks) \u2013 Containerized workers that perform the build and upload artifacts to S3.  </li> <li>Reverse Proxy Server \u2013 Streams built files from S3 to the user\u2019s browser for live preview or production hosting.  </li> <li>Database (PostgreSQL) \u2013 Stores users, projects, and deployment metadata.  </li> <li>Cloud Storage (AWS S3) \u2013 Holds final build outputs.  </li> </ul> <p>User \u2192 API Server \u2192 Build Server (ECS) \u2192 S3 Bucket \u2192 Reverse Proxy \u2192 Live URL</p>"},{"location":"functional/functional-usecases/","title":"Functional Use Cases","text":"<p>This section defines the main functional behaviors of the Deployment Pipeline (Vercel Clone). Each use case explains how different system components interact internally to deliver a key feature.</p>"},{"location":"functional/functional-usecases/#1-user-authentication","title":"1. User Authentication","text":"<p>Goal: Provide secure sign-up and login for users.</p> <p>Flow: 1. User sends a sign-up or login request to the API server. 2. Server validates input and checks the database for existing users. 3. Passwords are hashed and stored securely. 4. On successful login, a JWT token is generated and returned. 5. Subsequent requests include this token for authorization.</p> <p>System Behavior: - Validations ensure unique emails and secure passwords. - Tokens are time-bound and refreshable. - Unauthorized access attempts return appropriate errors.</p>"},{"location":"functional/functional-usecases/#2-project-management","title":"2. Project Management","text":"<p>Goal: Allow authenticated users to create and manage deployable projects linked to GitHub repositories.</p> <p>Flow: 1. User provides project name and GitHub repo URL. 2. API validates the URL format and ensures it\u2019s accessible. 3. A project entry is created in the database and linked to the user. 4. Frontend displays the project dashboard with deployment options.</p> <p>System Behavior: - Ensures no duplicate project names for a single user. - Maintains relationship between users, projects, and deployments. - Prepares metadata for future deployment builds.</p>"},{"location":"functional/functional-usecases/#3-build-and-deployment-execution","title":"3. Build and Deployment Execution","text":"<p>Goal: Automate the build and deployment process when a user triggers a deployment.</p> <p>Flow: 1. User triggers Deploy from the dashboard. 2. API creates a deployment record and pushes a build task to ECS. 3. The ECS container clones the GitHub repository from the provided URL. 4. The build process (<code>npm install</code>, <code>npm run build</code>, etc.) runs inside the container. 5. Build artifacts are uploaded to an S3 bucket. 6. Deployment status (<code>queued</code>, <code>running</code>, <code>success</code>, <code>failed</code>) is updated in the database.</p> <p>System Behavior: - Uses AWS ECS for isolated build execution. - Logs are collected and streamed back to the backend. - On successful build, an accessible URL is generated via CloudFront or reverse proxy.</p>"},{"location":"functional/functional-usecases/#4-reverse-proxy-and-file-streaming","title":"4. Reverse Proxy and File Streaming","text":"<p>Goal: Deliver the deployed React app to end users efficiently.</p> <p>Flow: 1. User accesses the generated deployment URL. 2. Reverse proxy receives the request and retrieves static assets from the S3 bucket. 3. The files are streamed back to the client\u2019s browser.</p>"},{"location":"functional/overview/","title":"Functional Overview","text":"<p>The Deployment Pipeline (Vercel Clone) automates the process of building, deploying, and hosting frontend applications directly from GitHub repositories. It enables users to go from source code to a live, shareable URL without manual setup or server configuration.</p>"},{"location":"functional/overview/#how-it-works","title":"How It Works","text":"<p>When a user provides a GitHub repository URL and triggers deployment, the system executes a series of automated functions that ensure seamless application delivery.</p>"},{"location":"functional/overview/#step-by-step-process","title":"Step-by-Step Process","text":"<ol> <li>Repository Cloning </li> <li>The API server authenticates the GitHub URL provided by the user.  </li> <li>The build server securely clones the source code repository into an isolated environment.  </li> <li> <p>Only the latest branch or commit is fetched to optimize performance and reduce build time.</p> </li> <li> <p>Automated Build Process </p> </li> <li>A build server, running as an ECS task, builds the project using pre-defined Docker images stored in AWS ECR.  </li> <li>The environment includes dependencies such as Node.js to compile React applications.  </li> <li> <p>Once the build completes, the system generates production-ready files (HTML, CSS, JS).</p> </li> <li> <p>Artifact Upload to AWS S3 </p> </li> <li>The built static files are uploaded to a designated S3 bucket.  </li> <li>The system assigns each deployment a unique directory or version ID for organized storage and rollback capability.  </li> <li> <p>Appropriate access policies are applied to ensure security and isolation per project.</p> </li> <li> <p>Serving via Reverse Proxy </p> </li> <li>A custom reverse proxy fetches files from S3 in real time and streams them to clients.  </li> <li>It ensures low latency, caching, and HTTPS support.  </li> <li>This allows users to instantly access the deployed application via a generated live URL.</li> </ol>"},{"location":"functional/overview/#core-functional-modules","title":"Core Functional Modules","text":"<p>The system is divided into several modules that work together to achieve complete automation:</p>"},{"location":"functional/overview/#1-user-authentication-and-autherization","title":"1. User Authentication and Autherization","text":"<p>Handles secure access to the system. - Users can sign up, log in, and manage their profiles. - Passwords are encrypted before storage. - JWT (JSON Web Tokens) or session-based authentication ensures secure API communication.</p>"},{"location":"functional/overview/#2-project-management","title":"2. Project Management","text":"<p>Links user accounts to their GitHub repositories. - Users can create, view, and manage projects. - Each project record stores metadata such as repository URL, project name, and user ID. - A single user can have multiple projects.</p>"},{"location":"functional/overview/#3-automated-build-deployment","title":"3. Automated Build &amp; Deployment","text":"<p>Responsible for compiling and preparing production builds. - The API server triggers a build job using AWS ECS tasks. - Each build is isolated and stateless, ensuring consistency and reproducibility. - Logs, build status, and progress are tracked and linked to a specific deployment record.</p>"},{"location":"functional/overview/#4-file-hosting-and-delivery","title":"4. File Hosting and Delivery","text":"<p>Ensures fast and reliable access to deployed applications. - Build artifacts are uploaded to AWS S3 with public-read or signed URL access. - A reverse proxy layer retrieves and streams these files to users in real time. - This design supports horizontal scaling for high-traffic applications.</p>"},{"location":"functional/overview/#5-database-management","title":"5. Database Management","text":"<p>Stores essential project data and deployment history. - PostgreSQL is used for relational data storage. - Contains three main tables:   - Users \u2192 Authentication and user profiles.   - Projects \u2192 Repository and configuration details.   - Deployments \u2192 Build metadata, status, and generated URLs. - The database enables tracking deployment versions, history, and ownership.</p>"},{"location":"functional/overview/#functional-flow-summary","title":"Functional Flow Summary","text":"<p>User \u2192 API Server \u2192 Build Server (ECS) \u2192 AWS S3 \u2192 Reverse Proxy \u2192 Live App</p>"},{"location":"use-cases/business-overview/","title":"Business Overview","text":""},{"location":"use-cases/business-overview/#objective","title":"Objective","text":"<p>To provide a seamless automated deployment solution for frontend developers who want to host React applications quickly, without manual configuration.</p>"},{"location":"use-cases/business-overview/#stakeholders","title":"Stakeholders","text":"<ul> <li>End Users (Developers): Use the platform to deploy and host React apps.</li> <li>Admin / DevOps Team: Maintain build servers, monitor deployments.</li> <li>Business Owner: Ensures scalability, manages billing and uptime.</li> </ul>"},{"location":"use-cases/business-overview/#business-problem","title":"Business Problem","text":"<p>Manual deployment and hosting are time-consuming and error-prone. This project provides one-click continuous deployment from GitHub to a live URL.</p>"},{"location":"use-cases/business-overview/#business-value","title":"Business Value","text":"<ul> <li>Reduces deployment time from hours to minutes.</li> <li>Simplifies hosting workflow for developers.</li> <li>Encourages CI/CD adoption. ``</li> </ul>"}]}